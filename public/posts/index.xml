<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Gabriel G. de Brito</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content on Gabriel G. de Brito</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gabrielgbrito@icloud.com (Gabriel G. de Brito)</managingEditor>
    <webMaster>gabrielgbrito@icloud.com (Gabriel G. de Brito)</webMaster>
    <copyright>Â© Gabriel G. de Brito (CC-BY-NC)</copyright>
    <lastBuildDate>Wed, 24 Apr 2024 18:37:24 -0300</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>I Completely Disagree With My Own Opinion</title>
      <link>http://localhost:1313/posts/i-completely-disagree-with-my-own-opinion/</link>
      <pubDate>Sat, 27 Apr 2024 20:59:59 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/i-completely-disagree-with-my-own-opinion/</guid>
      <description>That&amp;rsquo;s exactly it. I completely disagree with my own opinion!
Context I wrote 3 blogposts about text editors:
On text editors, on which I wrote about my text editor hopping journey and features I like (at the moment). A Review On My Own Post On Text Editors, on which I wrote about the Unix philosophy, graphical desktops, modes of editing and a bunch of other stuff. Another Update On Text Editors, on which I wrote about getting into Plan 9 From Bell Labs And I completely disagree with my opinion on those posts, so I&amp;rsquo;ll address my new philosophy here.</description>
      <content:encoded><![CDATA[<p>That&rsquo;s exactly it. I completely disagree with my own opinion!</p>
<h1 id="context">Context</h1>
<p>I wrote 3 blogposts about text editors:</p>
<ul>
<li><a href="http://localhost:1313/posts/on-text-editors/">On text editors</a>, on which I wrote about my
text editor hopping journey and features I like (at the moment).</li>
<li><a href="http://localhost:1313/posts/update-on-text-editors/">A Review On My Own Post On Text Editors</a>,
on which I wrote about the Unix philosophy, graphical desktops, modes of
editing and a bunch of other stuff.</li>
<li><a href="http://localhost:1313/posts/update-on-text-editors-again/">Another Update On Text Editors</a>, on
which I wrote about getting into <a href="https://plan9.io/plan9/">Plan 9 From Bell Labs</a></li>
</ul>
<p>And I completely disagree with my opinion on those posts, so I&rsquo;ll address my new
philosophy here.</p>
<h2 id="from-arch-to-alpine-back-to-arch-and-them-fedora">From Arch to Alpine, back to Arch and them&hellip; Fedora?</h2>
<p>As I said in the previous post of this series, I really switched my main machine
to Alpine, due to minimalism philosophy. And it was terrible. I stayed with it
for sometime, until all the problems on living computing as it was the 90&rsquo;s
finally made me go back to an operating system with modern goodies.</p>
<p>So I went back to Arch as it was the system I knew. But man, it requires effort.</p>
<p>I already understood, while using Plan 9 software, that &ldquo;high customizability&rdquo;
isn&rsquo;t actually a good thing (I&rsquo;ll not evolve this, maybe I&rsquo;ll write a proper
argument and not a mere &ldquo;my experience&rdquo; sometime), but I was still a minimalist.
This time, though, I wanted something that just works and has the software I
need. So I installed Fedora. And I loved it.</p>
<p>I loved it because it just worked. GNOME is great, it just works, it&rsquo;s
efficient, and the interface does not create mental overhead on it&rsquo;s use. Yeah,
it wastes some resources. Ok, at least the keyring works, the network works, the
audio works, the bluetooth works. Everything I want just works and is easy to
use.</p>
<h2 id="ok-then-and-the-editor">Ok then, and the editor?</h2>
<p>I got myself thinking about
<a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">LSP</a>. I used to think
it was distracting, and just compiling after writing solved all the issues that
could be solved by LSP. But what I noticed is that when I actually must not get
distracted, I&rsquo;m not coding: I&rsquo;m using pen and paper to figure out what I have to
code. And so LSP can actually be very useful for my workflow.</p>
<p>So I tried to use Emacs again. But I really did not like the way mouse works,
even with the menu bar enabled.</p>
<p>Well, there&rsquo;s that very popular editor with good LSP and mouse support&hellip;</p>
<p>Yeah I went back to Visual Studio Code.</p>
<h2 id="conclusions">Conclusions</h2>
<p>There&rsquo;s just nothing more to comment on. It&rsquo;s very obvious why this is just
better than everything I was doing for the last years.</p>
<p>Oh, actually, there&rsquo;s one more thing to comment: I only have language plugins in
VS Code (except for GitHub Copilot). Default dark+ theme, no other plugins.</p>
]]></content:encoded>
    </item>
    <item>
      <title>The Zen of Gabriel for Technology Development</title>
      <link>http://localhost:1313/posts/zen/</link>
      <pubDate>Wed, 21 Feb 2024 17:45:36 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/zen/</guid>
      <description>1- No human being should have to perform a work if it can be done by a machine.
2- Although there is really no difference between humans and technology, as technology is a fundamental part of the human condition.
3- Technology should be developed to overcome biological limitations of humans.
4- Thus, the pure humanism is contradictory, and the post-human stage of development is a desired goal.
5- The developed technology should be used for Good, not for Evil.</description>
      <content:encoded><![CDATA[<p>1- No human being should have to perform a work if it can be done by a machine.</p>
<p>2- Although there is really no difference between humans and technology,
as technology is a fundamental part of the human condition.</p>
<p>3- Technology should be developed to overcome biological limitations of humans.</p>
<p>4- Thus, the pure humanism is contradictory, and the post-human stage of
development is a desired goal.</p>
<p>5- The developed technology should be used for Good, not for Evil.</p>
<p>6- Although is really not possible to control whether it will be used for
the Good, or whether it will be used for the Evil.</p>
<p>7- If technology development arises from Evil, or the fight against Evil
leads to technology development, so be it. The technology should still be
used, with no regrets nor limitations except it&rsquo;s use, that should be for Good.</p>
<p>8- Tools have an intrinsic, generic use case. They may be used for something
else, if possible, but they always carry their intrinsic use case.</p>
<p>9- Thus, the interface of a piece of technology should empower the User to
perfom it&rsquo;s intrinsic, generic use case. No more, no less.</p>
<p>10- Although it may adapt for the specific use case and individuality of
it&rsquo;s User.</p>
<p>11- In the case it has to adapt, the more adaptative with the less
configuration, the better.</p>
<p>12- A solution may only use it&rsquo;s required resources, and reduce it&rsquo;s
requirements is a desired goal.</p>
<p>13- Although unused resources are also wasted.</p>
<p>14- In the case resources are idling, they may be used to a purpouse that
does not waste them. As stocks, for example.</p>
<p>15- Technology should be developed in a sustainable fashion.</p>
<p>16- Thus, the thirteenth guideline should be wisely followed to not lead to
the Evil.</p>
<p>17- If a piece of technology can not be held accountable, it&rsquo;s failure is
a human error.</p>
<p>18- When a piece of technology may be held accountable, it should become a
citizen of Our Civilization.</p>
<p>19- Although you may not like that if you&rsquo;re religious enough.</p>
<h2 id="appendix-a-computer-and-program-design">Appendix A: Computer and Program Design</h2>
<p>A.1- Computing is Art. Treat it accordingly.</p>
<p>A.2- Linked-lists are great for the Programmer.</p>
<p>A.3- Although they&rsquo;re not great for the Machine.</p>
<p>A.4- The same applies for abstractions and functional programming.</p>
<p>A.5- Convention is great. It leads to Cohesion and Coherence.</p>
<p>A.6- Although a bad Convention is often worse than no Convention at all.</p>
<p>A.7- Systems should not hide themselves. Hiding a Lion System in a Feline
abstraction may lead the Programmer to think it&rsquo;s actually a Cat.</p>
<p>A.8- Or worse, it may lead the User to think it&rsquo;s just Magic.</p>
<p>A.9- Programmers often implement more and more generic features than they
should, just because they can. This should be avoided.</p>
<p>A.10- One way to address this issue is giving less power to them.</p>
<p>A.11- Although this should be done wisely to not lead to featureless Systems.</p>
<p>A.12- Simplicity and Minimalism should be used with little moderation.</p>
<p>A.13- Although you may not know how much is little moderation unless you
program in Go.</p>
<p>A.14- The Instruction Set Architeture should be simple enough so the Student
can program in it&rsquo;s Assembly.</p>
<p>A.15- Syntax does matter, but Semantics are much more important.</p>
<p>A.16- Different Things should be visibly different.</p>
<p>A.17- Important Things should be quickly accessible, and important Information
should be visible. Similarly, non-important Things and Information should
be hidden, but accessible when needed.</p>
<p>A.18- A Computer should minimize the amount of computing the brain of the
User must do.</p>
<p>A.19- Don&rsquo;t forget the Joy of Computing.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Another Update On Text Editors</title>
      <link>http://localhost:1313/posts/update-on-text-editors-again/</link>
      <pubDate>Thu, 21 Dec 2023 01:49:27 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/update-on-text-editors-again/</guid>
      <description>(or How I Got Into The Nerdiest Thing Ever + Rant On Modern Unix) Some weeks ago I wrote a blogpost about my journey on text editor hopping, and them another blogpost reviewing my own post. Well, here we go again.
In the last post I wrote about Plasma and the Unix philosophy in the desktop but that&amp;rsquo;s mostly bullshit. And that&amp;rsquo;s why the Linux desktop is a mess.
Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc.</description>
      <content:encoded><![CDATA[<h1 id="or-how-i-got-into-the-nerdiest-thing-ever--rant-on-modern-unix">(or How I Got Into The Nerdiest Thing Ever + Rant On Modern Unix)</h1>
<p>Some weeks ago I wrote <a href="http://localhost:1313/posts/on-text-editors/">a blogpost</a> about my journey on
text editor hopping, and them <a href="http://localhost:1313/posts/update-on-text-editors/">another blogpost</a>
reviewing my own post. Well, here we go again.</p>
<p>In the last post I wrote about Plasma and the Unix philosophy in the desktop but
that&rsquo;s mostly bullshit. And that&rsquo;s why the Linux desktop is a mess.</p>
<p>Instead of the original Unix idea of multiple programs writing text to others,
the Linux desktop is based on other APIs like the X server itself, dbus and
etc.â£And often they don&rsquo;t talk the same language. QT vs GTK is an example of
this, alongside with desktop portals, notification daemons, etc.</p>
<p>Well, I wasn&rsquo;t happy with Plasma&rsquo;s design philosophy because of bloat. I tried
GNOME but it&rsquo;s worse. End up on XFCE.</p>
<p>XFCE is better as it&rsquo;s simple and minimal. But I really wanted to go back to
using window managers and stuff like that.</p>
<p>What I found out is that, in the end, what I really care about is having a sane
and cohesive shell (using &ldquo;shell&rdquo; as &ldquo;interface&rdquo;). Plasma is a kinda cohesive
graphical shell, but it&rsquo;s not that efficient. Menu-bar-driven, two-button mouse
systems, i.e., the modern graphical paradigm popularized by the Microsoft
Windows operating system, is not efficient.</p>
<p>One could argue that the Unix terminal is more efficient, but I found it very
incohesive. First, the shell language is a mess. Second, the command argument
syntaxes are very diverse. Third, the ANSI terminal itself. It&rsquo;s an ancient hack
that stick with us and should&rsquo;ve been dropped when graphical interfaces became
popular. We&rsquo;d never implemented simple graphics API though so the result is that
it&rsquo;s 2023 and we&rsquo;re still using curses. Also, modern Unix got a lot of stuff
wrong, mainly due to the Free Software Foundation and the GNU project push
towards the bloat. Much GNU documentation is acessible via the <code>info</code> pages that
nobody really knows how to read, some commands have a <code>--help</code>, some have the
manual (which is much better than any other alternative, <em>specially</em> <code>info</code>
pages). And the manual opens inside the pager with a broken view in my terminal
because it doesn&rsquo;t support bold.</p>
<p>And them we got Emacs. Emacs is actually a very cohesive shell, but it&rsquo;s
painfully slow and it&rsquo;s not particularly efficient. It&rsquo;s probably the least
painfull way to use the GNU system &ldquo;the way it was intented&rdquo; nowadays, which is
kinda funny because Emacs is it&rsquo;s own containeirized Lisp operating system.</p>
<p>Wandering through the web, I read some Rob Pike&rsquo;s papers and found out the
nerdiest thing in computing: <a href="https://plan9.io/plan9/">Plan 9 From Bell Labs</a>.
It&rsquo;s almost perfect. The graphical shell is extremelly efficient, the mouse
usage is geniously simple and easy, yet fast. The entire system is very simple
and straighforward. So much that I had the Plan 9 From User Space port installed
in my Debian system and in a couple hours I had learned everything I had to
learn to be as efficient as I&rsquo;m after years of learning Unix with my new shell
and toys.</p>
<p>Acme is specially a rather efficient shell. And, different from the hack that&rsquo;s
the graphical Emacs, it was meant to be a shell. Everything is so cool that I&rsquo;ll
be changing to a very minimalistic Unix system -
<a href="https://www.alpinelinux.org/">Alpine</a>, so I can have everything in busybox and
statically linked with musl - and using basically the Plan 9 tools and other
minimalistic software to do my computing. I liked Plan 9 so much that I&rsquo;m
writing my own <code>rio</code> clone for X11.</p>
<p>And I know exactly what I liked in it. Basically, the system allows, via the
mouse, easy and free exchanging of text between different programs, running in
parallel in the graphical environment, with a cohesive interface. It&rsquo;s possible
to create such shell for Unix, but it would be a rather difficult task. Much
difficultier than for Plan 9 as there would be no support from the system
itself. I may try it though.</p>
]]></content:encoded>
    </item>
    <item>
      <title>A Review On My Own Post On Text Editors</title>
      <link>http://localhost:1313/posts/update-on-text-editors/</link>
      <pubDate>Fri, 20 Oct 2023 21:24:49 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/update-on-text-editors/</guid>
      <description>Some time ago I wrote a blogpost about my journey in text editor hopping On the very bottom of the post, I talked about my overall current opinions on editors and how I may write one. Here I want to update that.
As a resume, I became more minimalist because I tried a lot of editors and addressed what really matters in an editor, what is really usefull. And I talked with more experienced people too.</description>
      <content:encoded><![CDATA[<p>Some time ago I wrote a
<a href="http://localhost:1313/posts/on-text-editors/">blogpost about my journey in text editor hopping</a>
On the very bottom of the post, I talked about my overall current opinions
on editors and how I may write one. Here I want to update that.</p>
<p>As a resume, I became more minimalist because I tried a lot of editors and
addressed what really matters in an editor, what is really usefull. And I
talked with more experienced people too.</p>
<p>Also, I found out that the Unix philosophy is really great, and that there&rsquo;s a
really neat way of applying it for a graphical environment. I&rsquo;ll talk about
that in the end of this post.</p>
<h2 id="the-compile-mode">The <em>compile-mode</em></h2>
<p>It&rsquo;s not that usefull. Yeah, I said it was my favorite feature from GNU Emacs
but I just changed my opinion. Follow the history:</p>
<p>I was upset that Emacs was terribly slow in my University computers. So
I was using Vim. For the sake of keeping with the defaults, I
wasn&rsquo;t using the plugin I wrote that mimics <em>compile-mode</em> for it,
<a href="https://github.com/gboncoffee/run.vim">run.vim</a>. I tried Vim&rsquo;s <code>:make</code> but
it&rsquo;s simply terrible. One of my teachers uses Vim, and I asked him what he
uses for compiling. He said that he just opens another terminal window and
compiles from there, jumping errors manually. When I told him I would like
something that jumps errors for me and stuff like that, he just told me that
he never needed that much efficiency. He&rsquo;s not programming on the market,
he&rsquo;s just a scientist whatsoever.</p>
<p>When thinking about that, I found out that a lot of times I just can&rsquo;t use
<em>compile-mode</em> or some clone because I need to test programs interactively
in the terminal, or when programming for X I need to test inside of
Xephyr. Furthermore, ditchin made me open the eyes for a lot of other editors.</p>
<h2 id="trying-stuff-out">Trying stuff out</h2>
<p>On the modal side, I&rsquo;m using both Kakoune and Vim. Vim is a big editor with
tons of features and lacks good mouse support. Kakoune is a small editor
with not that much features and lacks good mouse support. Of course, both
are modal and I&rsquo;m not really into modal editing anymore.</p>
<p>Besides that, window managing with Kakoune is a mess, because as it creates
multiple terminal or tmux windows, the command prompt always changes location
and I need to remember what window is the main one to don&rsquo;t close them all. I
really like Kakoune&rsquo;s multiple cursor support though.</p>
<p>Kakoune does try to follow more the Unix philosophy them Vim, though. But
there are things that I don&rsquo;t like in the way it does it. For example,
while editing Go code, I found out that if I pipe my file into <code>gofmt</code> with
Kakoune&rsquo;s pipe command but some syntax error make <code>gofmt</code> fail, Kakoune will
substitute my entire file for nothing (the stdout of a failed <code>gofmt</code>) and
I must type <code>u</code> to undo that. That&rsquo;s not that big of a deal but pisses me off.</p>
<p>Also, I think that modal editing creates an unecessary overhead and just
using control and meta keybinds is better. The lack of good mouse support
in both editors is not good too.</p>
<p>So yeah, they&rsquo;re very great editors if you code in a 1980&rsquo;s text terminal
without mouse. But in the 1980&rsquo;s text terminal you also wouldn&rsquo;t have color
support so I don&rsquo;t know why both editors have syntax highlighting.</p>
<h1 id="ditching-modal">Ditching modal</h1>
<p>I&rsquo;m using three other non-modal editors nowadays besides Emacs:</p>
<ul>
<li><a href="https://micro-editor.github.io/">Micro</a>, a modern Nano replacement.</li>
<li><a href="https://github.com/deadpixi/sam">A modern Sam version</a>, an editor from Rob
Pike for the Bell Lab&rsquo;s Plan 9 Operating System.</li>
<li><a href="https://apps.kde.org/kwrite/">KWrite</a>, an editor for the KDE Plasma
environment.</li>
</ul>
<p>I don&rsquo;t like KWrite that much because I cannot deactivate the syntax
highlighting. It&rsquo;s my system&rsquo;s default editor right now thought because I&rsquo;m
using KDE Plasma and I still didn&rsquo;t find what to use. I won&rsquo;t use KWrite for
real coding.</p>
<p>What about Sam? Sam is for nerds. And I&rsquo;m a nerd. Probably the world would be
better place if we all just used Plan 9&rsquo;s design in everything (with a dark mode
thought). But unfortunatelly it isn&rsquo;t. Using Sam inside X is really clunk
because it looks like a virtual machine: I have a window manager and windows
inside another window. And Sam looks like you should learn the entire command
language and use it almost entirely from the command window. But probably
because I&rsquo;m too lazy to create a bunch of keybinds to it. It has excellent mouse
support, but I need to use it a lot more inside it, and that hurts.</p>
<p>Micro is good, fast, has decent keybinds (I prefer Emacs&rsquo; ones thought) and a
good mouse support. But lacks piping text through commands, and that&rsquo;s not
acceptable.</p>
<p>Both Micro and Sam lacks trailing whitespace highlighting, which I like a lot.</p>
<p>Sam also lacks support for a vertical column showing me the 80th text column,
and that&rsquo;s very frustrating because it&rsquo;s such a simple feature. Also, lacks
editorconfig support, which is also not acceptable.</p>
<p>With Micro I cannot change files with the mouse too, which for a mouse-centric
editor is not cool. And I need to keep line numbers in the left side of the
screen to see if my lines are being wrapped and to format the text. I don&rsquo;t
like those line numbers, they&rsquo;re a waste of space.</p>
<h2 id="the-unix-philosophy-inside-x-sessions">The Unix Philosophy Inside X Sessions</h2>
<p>I&rsquo;m using KDE Plasma and if you think I&rsquo;m not allowed to call myself a
minimalist because I&rsquo;m liking it, so be it. But a good desktop environment,
not resouce-heavy, with plenty of great tools and integration is very cool.
The graphical interface and the stacking window system are two of the best
things computer people ever made. Plasma reminds me a little about MacBooks,
and that probably means someday, when I have the money, I&rsquo;ll buy myself a Mac.</p>
<p>The integration between stuff inside Plasma is very cool. I can open Dolphin
and manage files much better than inside the terminal, or with some program
like Midnight Commander. Drag-and-drop is wonderfull. Having an applet in my
panel that allows me to control <em>whatever</em> music player I use is very cool.</p>
<p>So, of course, I want an editor that can be integrated in the desktop. This
does not necessary means a graphical editor thought, as it&rsquo;s entirely possible
to open the editor inside the terminal from the desktop applications, and have
very good mouse support in it.</p>
<h2 id="the-overall-idea">The overall idea</h2>
<p>I&rsquo;ll certainly create a new editor. And it&rsquo;ll follow this:</p>
<ul>
<li>Support for some kind of trailing whitespace highlighting and text-width
column;</li>
<li>Emacs-inspired keybinds but without keychords;</li>
<li>Great mouse support inspired by Sam;</li>
<li>Just a sane UI that does not keep in my way and show me everything I need to
see;</li>
<li>Support for editorconfig via integration with the editorconfig C program.</li>
</ul>
<p>I&rsquo;ll probably write it in Go as it has great support for UTF-8 and is a very
simple and efficient language.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Notes on Transhumanism</title>
      <link>http://localhost:1313/posts/notes-on-transhumanism/</link>
      <pubDate>Sun, 15 Oct 2023 01:34:28 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/notes-on-transhumanism/</guid>
      <description>In the sense that language and fire were there before the evolving of the Homo sapiens, the species was enhanced by technology since it&amp;rsquo;s beggining. There&amp;rsquo;s a sense that technology itself is a part of humans.
Humans, though, are self-described by their biological nature - carbon-based material instances from the Homo sapiens species. This is the sense that the technology is not a part of humans but rather just a tool used to enhance their own lives.</description>
      <content:encoded><![CDATA[<p>In the sense that language and fire were there before the evolving of the <em>Homo
sapiens</em>, the species was enhanced by technology since it&rsquo;s beggining. There&rsquo;s
a sense that technology itself is a part of humans.</p>
<p>Humans, though, are self-described by their biological nature - carbon-based
material instances from the <em>Homo sapiens</em> species. This is the sense that the
technology is not a part of humans but rather just a tool used to enhance their
own lives.</p>
<p>However, as described in the first paragraph, the &ldquo;<em>Homo sapiens</em>-based
humanity&rdquo; itself only evolved after technology, with it. There were never a
sense of humankind without technology. And thus we need to clarify the
difference between the <em>Homo sapiens</em> biological society and the bigger
civilization we are constructing while being humans.</p>
<p>Where and when this civilization started is not relevant for us, as where and
when exactly the first human was born. Both are rather long transitioning
processes between the unconscious, clearly-not-our-civilization life-based
society and a stage were we can undoubtedly claim be part of our civilization.
Also, we may discuss if this bigger civilization started before or after <em>Homo
sapiens</em>, but that&rsquo;s not relevant too.</p>
<p>From now on, I&rsquo;ll call the civilization we live, that may have started before
the modern human species and may expand to other carbon-or-not-based species
or any other intelligent form that achieve the citizen status of our
civilization in the future, as just &ldquo;our civilization&rdquo;.</p>
<p>So, if we achieve a status were our biological nature is irrelevant - thus
overcoming our humanity - i.e., transferring the dominant intelligent creature
form of the civilization from <em>Homo sapiens</em> to another non-biological form, or
even keeping our human bodies but enhancing them to a level were their
biological nature is irrelevant, we achieved a &ldquo;post-human&rdquo;, or &ldquo;trans-human&rdquo;
stage.</p>
<p>It&rsquo;s important to notice that &ldquo;enhancement&rdquo; is generally defined only for the
civilization as a whole. This happens because there&rsquo;s no clear one that defines
what is &ldquo;enhancement&rdquo; - multiple persons may have to make this choice in
multiple different situations. - In some cases, the choice is individually made:
if one chooses to take a medicine, one considers it a technological enhancement.
Other cases may be compulsory, either by government - like vacination - or in an
indirect manner - like internet connection: you&rsquo;re not mandated to have one, but
most people simply would be disabled to make financial transactions or apply for
a job without one, even though they may consider the internet a bad technology.</p>
<p>When we consider civilization as a whole, though, we can define as &ldquo;enhancement&rdquo;
anything that either increases our rank in the Kardashev scale - noticing that
wasted energy, like the energy that microprocessors liberate as heat, is not
considered.</p>
<p>It&rsquo;s also important to notice that it is not usefull to thing about
technological enhancements individually, as the concept of an individual may be
temporary. As our civilization is based on biological instances, clearly
separated from others, we currently have the concept of &ldquo;individual&rdquo;. In the
future, though, this concept may be overcomed and the civilization may be just a
single big instance. If you think this does not make sense, notice how
technology - specially computing - has evolved in order to keep information
synced between different human brains across the globe.</p>
<p>Both the problem of &ldquo;who chooses what is enhancement&rdquo; and the individual concept
show that there are problems in our civilization that aren&rsquo;t solved by creating
a new machine or something alike. A lot of problems like hungry would be
solvable with our technical level today, but they aren&rsquo;t because of politics
(not just stuff that happens in the state, but politics in general). If one does
not view politics as a technology - view with which I disagree - this would mean
that &ldquo;technological enhancement&rdquo; is not the only thing we need to use to solve
our problems.</p>
<p>Furthermore, it&rsquo;s important to notice that using technological enhancement to
increase our rank in the Kardashev scale fast is not our main goal. This should
be repeated a lot of times to be clear. Incresing our rank in the Kardashev
scale fast using technological enhancement is not our main goal. This happens
because, as said before, we have the concept of &ldquo;individual&rdquo; and our
civilization is not centrally controlled. This means that a lot of times some
groups or individuals may have conflict with others as they seek their own
interests. It&rsquo;s clear for us that we should not sacrifice some individuals so
the civilization is enhanced. If we kept with increasing our rank fast as our
main goal without caring for the individual, very dangerous ideas may arise,
like eugenics. The United Nations&rsquo; Universal Declaration of Human Rights is a
great ethic parameter to keep in mind.</p>
<p>Besides that, those dangerous ideas probably would only produce harm to our
civilization in the long term, so they won&rsquo;t actually increase our rank.
Probably, keeping with the goal of providing dignity for all individuals via the
welfare state and social democracy is the currently most efficient way of
increasing our rank in the long term.</p>
<p>As a resume: currently, the best way to seek for the post-human stage is to help
empowering individuals in overcoming their personal disabilities - which can
mean from helping solving hungry to creating gadgets for blind and/or deaf
people, passing through just generally creating technology and solving people&rsquo;s
problems. Of course, this does not mean that jobs that aren&rsquo;t directly involved
in the creation of technology aren&rsquo;t usefull for our goal. The creation of
technology depends directly and indirectly from virtually all jobs that exists
in our society nowadays.</p>
<p>It&rsquo;s also important to notice that this does not mean that pure science, human
science, philosophy, entertainment and other work areas that are tipically
thrown in the &ldquo;not usefull&rdquo; group by a limited and stupid common sense are
actually usefull. Pure and human sciences and philosophy are technology
developments by themselves and they help our civilization. Entertainment is also
important as art and sports are also technology and we need to have fun to be
sane.</p>
<p>It&rsquo;s clear for us that evolving our civilization is not a general goal, in the
sense that lots of people nowadays just does not care in sacrificing other
people to reach their personal goals.</p>
<p>Clearly, the mental technology - i.e., technology that is just idea and/or
information, like language or software and concepts like ideologies, gender or
behaviour - are the most difficult to develop. That means that probably the
greatest achivement of our civilization so far is our rich language systems.</p>
<p>Clearly, pure biological beings have lots of disadvantages over
technologically-enhanced ones. Some political ideologies view the idea of
&ldquo;overcoming the boundaries of the human species&rdquo; as a bad thing. It&rsquo;s actually
exactly what our civilization had been trying to do since the evolving of the
<em>Homo sapiens</em>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>On Text Editors</title>
      <link>http://localhost:1313/posts/on-text-editors/</link>
      <pubDate>Wed, 20 Sep 2023 23:58:40 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/on-text-editors/</guid>
      <description>Here, I&amp;rsquo;ll talk a little about my journey with a lot of text editors and what I&amp;rsquo;m currently liking. Maybe I&amp;rsquo;ll eventually try creating my own with the ideas resumed here.
On Text Editors In my brief journey on computer programming - about three years right now - I hopped text editor a lot. A lot.
My first text editor was IDLE. It&amp;rsquo;s an extremelly simple text editor for Python written by Guido Van Rossum himself.</description>
      <content:encoded><![CDATA[<p>Here, I&rsquo;ll talk a little about my journey with a lot of text editors and what
I&rsquo;m currently liking. Maybe I&rsquo;ll eventually try creating my own with the ideas
resumed here.</p>
<h1 id="on-text-editors">On Text Editors</h1>
<p>In my brief journey on computer programming - about three years right now - I
hopped text editor a lot. <em><strong>A lot</strong></em>.</p>
<p>My first text editor was
<a href="https://docs.python.org/3/library/idle.html">IDLE</a>. It&rsquo;s an extremelly simple
text editor for Python written by Guido Van Rossum himself. It features syntax
highlighting, integrated repl and executing environment and probably more
features that I never used because I was a begginer. In retrospect, I like it&rsquo;s
simplicity.</p>
<p>I hopped to <a href="https://www.jetbrains.com/pycharm/">JetBrain&rsquo;s PyCharm</a> a few
months into learning programming. Back then, I was running a Windows laptop with
4gb of RAM and an Intel i3 (I still use this very same hardware, but with
another 8gb stick and Arch Linux). Of course, I was overhelmed with the
features, and it runned <em>terribly</em> slow. It was so painfull that I quitted
programming for about a month. Luckily, I got motivation again after I
discovered Linux, and switched my machine to Ubuntu. A few months using it, I
started using another JetBrains editor,
<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>. It&rsquo;s very similar to PyCharm,
but for Java. At the time, I wasn&rsquo;t really understanding what I was doing, I
just kept using stuff I knew worked and though it was the way to go.</p>
<p>Eventually, I hopped to the nowadays everyone&rsquo;s favorite,
<a href="https://code.visualstudio.com/">Microsoft&rsquo;s Visual Studio Code</a>. Still, it was
slow (<a href="https://www.phoronix.com/news/HTML5-Golang-Desktop-Apps">Electron</a>) but
kinda manageable. At this point I was understanding something about what I was
doing, but not everything. I could compile a Java program from the terminal, I
knew how to manage files in the terminal, etc etc etc. And my hand was hurting a
lot because of the intense use of the mouse and the swap between it and the
keyboard.</p>
<p>So I learned about the most loved one, <a href="https://www.vim.org/">Vim</a>. I switched
to it in a gradual fashion. Of course, I haven&rsquo;t documented the extremelly
extensive history of adding and removing plugins, switching to
<a href="https://neovim.io/">Neovim</a>, switching back to plain Vim, etc etc etc. When I
was in a more minimalist phase, I removed plugins, and vice-versa. I learned a
lot about everything related to computers and computer programming during that
period.</p>
<p>I was using a very customized Neovim with
<a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">LSP</a> and
<a href="https://tree-sitter.github.io/tree-sitter/">TreeSitter-based</a> syntax
highlighting and all those fancy stuff that slowed it down, when I learned about
<a href="https://helix-editor.com/">Helix</a>. I switched to it because it had almost
everything I had in Neovim with almost no configuration. It hadn&rsquo;t a plugin that
I wrote to Neovim, tho: <a href="https://github.com/gboncoffee/run.lua">run.lua</a>. I like
compile-driven development, so not having to switch to another
<a href="https://github.com/tmux/tmux">tmux</a> pane, pressing the up key, enter and them
figuring out where the previous compilation ended was very cool. Well, Helix
didn&rsquo;t had that and I couldn&rsquo;t add it as it does not have any extension system
(maybe this changed as you&rsquo;re reading). Anyways, I moved back to Neovim after
some time. Without LSP!</p>
<p>I always liked the idea of <a href="https://en.wikipedia.org/wiki/Emacs">Emacs</a>. But I
didn&rsquo;t want to drop modal editing. Anyways, I switched to Emacs with
<a href="https://github.com/emacs-evil/evil">evil</a>, i.e., Vim emulation. I dropped about
a month latter because the input lag was painfull. And I wanted minimalism.</p>
<p>So, I switched to <a href="http://kakoune.org/">Kakoune</a>. I configured and liked it,
specially the editing model. It&rsquo;s very minimalist, and I liked. It had a <code>make</code>
wrapper similar to Emacs&rsquo; <code>compile-mode</code> that I always liked. Kakoune&rsquo;s, tho,
was simpler and not that usefull.</p>
<p>When I got into the university, colleagues convinced me to switch back to Vim. I
created a very simple configuration, and was kinda happy with it. But Vim always
felt like a bunch of improvisations to me. Some day, in the little middle-year
vacation, I tried Emacs with it&rsquo;s default keybinds. I got used to not having
modal editing very quickly. Emacs is almost a perfect environment. But it&rsquo;s
exactly that: a Lisp environment. Not a text editor. I&rsquo;m writing from it right
now.</p>
<p>So, if I&rsquo;m writing this, of course it means I&rsquo;m not very happy with
Emacs. Mainly, I think it&rsquo;s overcomplicated and - as I said - more like a Lisp
environment that should have been a text editor than a text editor.</p>
<p>Anyways, after this historical introduction, I&rsquo;ll talk about what I learned I
like and what I learned I don&rsquo;t like.</p>
<h2 id="design">Design</h2>
<p>I readed <a href="https://arxiv.org/abs/2008.06030">On The Design of Text Editors</a> from
Nicolas Rougier. I don&rsquo;t agree with him in everything, but I liked the
overall. I don&rsquo;t like margins, and I think allowing the use of the mouse a
little more would be really great. Also, I don&rsquo;t like it&rsquo;s extensive use of
typesetting.</p>
<h2 id="syntax-highlighting-and-typesetting">Syntax Highlighting and Typesetting</h2>
<p>I&rsquo;m very into
<a href="http://www.linusakesson.net/programming/syntaxhighlighting/">no/minimal syntax highlighting</a>
and I kinda liked some ideas of
<a href="https://buttondown.email/hillelwayne/archive/46a17205-e38c-44f9-b048-793c180c6e84">semantic highlighting</a>.
If I ever create a text editor, I&rsquo;ll probably just add code syntax for strings
and comments. Maybe no syntax at all. For Emacs and Vim, I created a color theme
that removes syntax except for strings and comments, it&rsquo;s called Cyber Cafe, for
<a href="https://github.com/gboncoffee/cybercafe-emacs-theme">Emacs</a> and for
<a href="https://github.com/gboncoffee/cybercafe-vim-theme">Vim</a>.</p>
<p>For markup languages, I really liked the idea of changing the typesetting
according. Of course, this is only proper achieved with font-size changes and
variable-pitch fonts when using a graphical text editor. And graphical text
editors are just better.</p>
<h2 id="keybinds">Keybinds</h2>
<p>I just want a great set that allows me to achieve everything via the keyboard
when I want, navigate fast and made edits fast without making my hands and
fingers tired. Doesn&rsquo;t matter if it&rsquo;s modal or not. Actually, probably Emacs
keybinds are the better for coding.</p>
<h2 id="the-mouse">The Mouse</h2>
<p>I liked the way <a href="https://plan9.io/plan9/">Plan 9 and Acme</a> graphical interfaces
work. I was into tilling window managers before, but nowadays I like using a
stacking one. What I&rsquo;m into is using the mouse for navigation sometimes, so
having a proper mouse support that uses all three buttons is great.</p>
<h2 id="other-utilities-and-integrations">Other Utilities And Integrations</h2>
<p>My text editor should also have a great file manager and a fast git UI. I do not
need a mail client, nor tetris, nor web browser, nor web server, nor dunnet, nor
an ELISA clone. It should have a great way to interact with all these utilities,
tho. In a beautiful Unix fashion.</p>
<p>My favorite feature of Emacs is the extremelly simple <code>compile-mode</code>. It allows
you to run a command fast, and parses compiler output for jumping between errors
and etc. This is really great, I really like it. My editor should have
first-class support for compilers. There&rsquo;s simply no reason to not have. And no,
LSP is not the way to go (I have no article to link here as this is just too
unpopular. I think I&rsquo;ll have to write something about that).</p>
<p>Not only compilers, but repls too! Integration with repls is very great, and I
like repl-driven development for languages like Haskell, Lisp, OCaml and Lua.</p>
<p>But, this does not mean an integrated terminal. The way to go is opening your
editor from within a terminal, and not the opposite. That terminal session
should be used to manage various other background jobs like web servers and
stuff.</p>
<h2 id="performance">Performance</h2>
<p>Of course the editor should be graphical, but performance should be a
priority. I should be able to use it as my commit editor without feeling pain,
and opening it just for quick edits.
<a href="https://en.wikipedia.org/wiki/Qt_(software)">I guess we know the way to go</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Stupid Sorting</title>
      <link>http://localhost:1313/posts/stupid-sorting/</link>
      <pubDate>Tue, 12 Sep 2023 10:02:53 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/stupid-sorting/</guid>
      <description>The first topic in &amp;ldquo;Algoritmos e Estruturas de Dados II&amp;rdquo; (&amp;ldquo;Algorithms and Data Structures II&amp;rdquo;) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It&amp;rsquo;s not really that usefull but it&amp;rsquo;s a great example to learn. Then we learn stuff like the Insertion Sort, which&amp;rsquo;s actually usefull and more complex to understand.
But, as stupid as Selection Sort is, it&amp;rsquo;s kinda straightforward. What about some really, really stupid and useless sorting algorithms?</description>
      <content:encoded><![CDATA[<p>The first topic in &ldquo;Algoritmos e Estruturas de Dados II&rdquo; (&ldquo;Algorithms and Data
Structures II&rdquo;) classes are sorting algorithms. The first one we learn is the
stupid Selection Sort. It&rsquo;s not really that usefull but it&rsquo;s a great example to
learn. Then we learn stuff like the Insertion Sort, which&rsquo;s actually usefull and
more complex to understand.</p>
<p>But, as stupid as Selection Sort is, it&rsquo;s kinda straightforward. What about some
really, really stupid and useless sorting algorithms?</p>
<p>For this algorithms I used some <code>#includes</code> and a simple function that checks if
an array is sorted. The entire source is available
<a href="https://gist.github.com/gboncoffee/2ecfacb0bc7f03626e4c1d2e4d00253f">here at GitHub</a>.</p>
<h2 id="kill-sort">Kill Sort</h2>
<p>Sorts the array by removing unsorted itens. Returns the final size.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">int</span> <span style="color:#89b4fa">kill_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>	<span style="color:#f38ba8">int</span> pad <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>	<span style="color:#cba6f7">for</span> (<span style="color:#f38ba8">int</span> i <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">1</span>; i <span style="color:#89dceb;font-weight:bold">&lt;</span> n; i<span style="color:#89dceb;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>		<span style="color:#cba6f7">if</span> (v[i] <span style="color:#89dceb;font-weight:bold">&lt;</span> v[i <span style="color:#89dceb;font-weight:bold">-</span> <span style="color:#fab387">1</span> <span style="color:#89dceb;font-weight:bold">-</span> pad])
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>			pad<span style="color:#89dceb;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>		<span style="color:#cba6f7">else</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>			v[i <span style="color:#89dceb;font-weight:bold">-</span> pad] <span style="color:#89dceb;font-weight:bold">=</span> v[i];
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>	<span style="color:#cba6f7">return</span> n <span style="color:#89dceb;font-weight:bold">-</span> pad;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span>}</span></span></code></pre></div>
<p>The cool thing about this one is that it keeps the pointer valid. Of course,
it&rsquo;s usefull if we want a sorted array but don&rsquo;t need all the elements. It&rsquo;s
linear too, which is very cheap, but it writes a lot, and that&rsquo;s not great if
writes are expensive.</p>
<h2 id="thanos-sort">Thanos Sort</h2>
<p>Sorts the array by removing a random half of it until it&rsquo;s sorted. Returns the
final array pointer and sets n to it&rsquo;s size.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">int</span><span style="color:#89dceb;font-weight:bold">*</span> <span style="color:#89b4fa">thanos_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>	<span style="color:#89b4fa">srand</span>(<span style="color:#89b4fa">time</span>(<span style="color:#89dceb">NULL</span>));
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>	<span style="color:#cba6f7">while</span> (<span style="color:#89dceb;font-weight:bold">*</span>n <span style="color:#89dceb;font-weight:bold">&gt;</span> <span style="color:#fab387">1</span> <span style="color:#89dceb;font-weight:bold">&amp;&amp;</span> <span style="color:#89dceb;font-weight:bold">!</span><span style="color:#89b4fa">sorted</span>(v, <span style="color:#89dceb;font-weight:bold">*</span>n)) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>		<span style="color:#cba6f7">if</span> (<span style="color:#89b4fa">random</span>() <span style="color:#89dceb;font-weight:bold">%</span> <span style="color:#fab387">2</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>			v <span style="color:#89dceb;font-weight:bold">+=</span> <span style="color:#89dceb;font-weight:bold">*</span>n <span style="color:#89dceb;font-weight:bold">/</span> <span style="color:#fab387">2</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>		}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>		<span style="color:#89dceb;font-weight:bold">*</span>n <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#89dceb;font-weight:bold">*</span>n <span style="color:#89dceb;font-weight:bold">/</span> <span style="color:#fab387">2</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span>	<span style="color:#cba6f7">return</span> v;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span>}</span></span></code></pre></div>
<p>Very similar to Kill Sort. Unfortunatelly, this one leads to much more data loss
and does not have predictable behaviour. But it does not make a single write in
the array and runs in logarithmic time. Extremelly cheap. Also, it may not keep
the pointer valid, and that&rsquo;s why it returns a new one. This should be used with
caution to not cause memory leaks.</p>
<h2 id="random-sort">Random Sort</h2>
<p>Sorts the array by randomizing a sequence and them checking if it&rsquo;s sorted.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">void</span> <span style="color:#89b4fa">random_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>	<span style="color:#f38ba8">int</span> x, y, tmp;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>	<span style="color:#89b4fa">srand</span>(<span style="color:#89b4fa">time</span>(<span style="color:#89dceb">NULL</span>));
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>	<span style="color:#cba6f7">while</span> (<span style="color:#89dceb;font-weight:bold">!</span><span style="color:#89b4fa">sorted</span>(v, n)) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>		<span style="color:#cba6f7">for</span> (<span style="color:#f38ba8">int</span> i <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">0</span>; i <span style="color:#89dceb;font-weight:bold">&lt;</span> n; i<span style="color:#89dceb;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>			x <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#89b4fa">random</span>() <span style="color:#89dceb;font-weight:bold">%</span> n;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>			y <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#89b4fa">random</span>() <span style="color:#89dceb;font-weight:bold">%</span> n;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>			tmp <span style="color:#89dceb;font-weight:bold">=</span> v[x];
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>			v[x] <span style="color:#89dceb;font-weight:bold">=</span> v[y];
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>			v[y] <span style="color:#89dceb;font-weight:bold">=</span> tmp;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span>		}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">14</span><span>}</span></span></code></pre></div>
<p>This one is fun. It has a little chance of sorting the array in a single
iteration. I tested with an array with 10 elements and it usuallys takes between
300 thousand and 700 thousand iterations to finish. As it have a chance of
running a single iteration, it have a chance of never sorting at all too.</p>
<h2 id="intelligent-design-sort">Intelligent Design Sort</h2>
<p>Sorts the array by the following principle:</p>
<ul>
<li>There&rsquo;s n! chance of the array being sorted;</li>
<li>So it must have been sorted by an intelligent designer.</li>
</ul>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#f38ba8">void</span> <span style="color:#89b4fa">intelligent_design_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>	(<span style="color:#f38ba8">void</span>) v;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>	(<span style="color:#f38ba8">void</span>) n;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>}</span></span></code></pre></div>
<p>This is the cheapest algorithm here. Runs in constant time and uses only a
single stack frame of memory <em>at all, without compiler optimization</em>. I&rsquo;ve only
ever saw very few functions cheapest than this in computer science, and they&rsquo;re
usually not usefull at all.</p>
<h2 id="miracle-sort">Miracle Sort</h2>
<p>Sorts the array by waiting and hoping cosmic rays are going to flip the memory
so the array get&rsquo;s sorted.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#f38ba8">void</span> <span style="color:#89b4fa">miracle_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>	<span style="color:#cba6f7">while</span> (<span style="color:#89dceb;font-weight:bold">!</span><span style="color:#89b4fa">sorted</span>(v, n))
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>		<span style="color:#89b4fa">sleep</span>(<span style="color:#fab387">5</span>);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>}</span></span></code></pre></div>
<p>Yeah it just sits there and patiently waits for a miracle. You can adjust the
sleep time to change the behaviour of the algorithm: more time will lead to a
slightly slower sort, but less CPU usage. Less time will lead to a slightly
faster sort, but more CPU usage.</p>
<h2 id="schrodinger-sort">Schrodinger Sort</h2>
<p>It&rsquo;s not sorted nor unsorted until you check it.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#f38ba8">int</span> <span style="color:#89b4fa">schrodinger_sort</span>(<span style="color:#f38ba8">int</span> <span style="color:#89dceb;font-weight:bold">*</span>v, <span style="color:#f38ba8">int</span> n)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>{
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>	<span style="color:#cba6f7">return</span> <span style="color:#89b4fa">sorted</span>(v, n);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>}</span></span></code></pre></div>
<p>It sorts the array by telling you if it&rsquo;s sorted or not, so you decides what to
do. Quantum mechanics are really cool, aren&rsquo;t they?</p>
]]></content:encoded>
    </item>
    <item>
      <title>SimulaÃ§Ãµes</title>
      <link>http://localhost:1313/posts/simulacoes/</link>
      <pubDate>Sun, 22 Jan 2023 17:51:55 -0300</pubDate><author>gabrielgbrito@icloud.com (Gabriel G. de Brito)</author>
      <guid>http://localhost:1313/posts/simulacoes/</guid>
      <description>Aparentemente, Ã© mais provÃ¡vel que vivamos numa simulaÃ§Ã£o computadorizada do que num Universo real. Se Ã© que isso sÃ£o conceitos passÃ­veis de aceitaÃ§Ã£o. Como diferenciar uma simulaÃ§Ã£o de um Universo real? Assume-se que hÃ¡ uma realidade, visto que coisas existem, ou, no mÃ­nimo, eu existo, entÃ£o eu sou real. NÃ£o hÃ¡, conhecida em nosso Universo, qualquer simulaÃ§Ã£o computadorizada que simule o Universo tal qual ele Ã©, incluindo civilizaÃ§Ãµes inteligentes. Sendo assim, a chance de estarmos numa simulaÃ§Ã£o provavelmente Ã© maior que a de nÃ£o estarmos.</description>
      <content:encoded><![CDATA[<p>Aparentemente, Ã© mais provÃ¡vel que vivamos numa simulaÃ§Ã£o computadorizada do que
num Universo real. Se Ã© que isso sÃ£o conceitos passÃ­veis de aceitaÃ§Ã£o. Como
diferenciar uma simulaÃ§Ã£o de um Universo real? Assume-se que hÃ¡ uma realidade,
visto que coisas existem, ou, no mÃ­nimo, eu existo, entÃ£o eu sou real. NÃ£o hÃ¡,
conhecida em nosso Universo, qualquer simulaÃ§Ã£o computadorizada que simule
o Universo tal qual ele Ã©, incluindo civilizaÃ§Ãµes inteligentes. Sendo assim,
a chance de estarmos numa simulaÃ§Ã£o provavelmente Ã© maior que a de nÃ£o estarmos.</p>
<p>PorÃ©m, o fato Ã© que, sendo o nosso Universo uma mera realidade simulada ou nÃ£o,
aparentemente nÃ£o hÃ¡ o que diferencia uma realidade de uma simulaÃ§Ã£o. Para nÃ³s,
bits em uma mÃ¡quina, nÃ£o hÃ¡ diferenÃ§a entre estarmos vivos e estarmos sendo
simulados, tendo em vista que nosso mundo Ã©, de um jeito ou de outro. Ã,
simulado ou nÃ£o.</p>
<p>Nosso mundo, sendo, nÃ£o hÃ¡ sentido em preocupar-se com questÃµes como essa (se Ã©
que <em>hÃ¡</em> sentido, em algo). Ã fato que me preocupo mesmo assim. SimulaÃ§Ã£o ou
nÃ£o, eu ainda terei prova de anÃ¡lise linguÃ­stica e gramÃ¡tica na segunda-feira
prÃ³xima, e acredito que, como nÃ£o hÃ¡ diferenÃ§a entre vivermos em uma simulaÃ§Ã£o
ou nÃ£o, ei de me preocupar mais com os fatos mais simples: decididamente,
o papel de parede que eu usarei no meu computador faz mais diferenÃ§a Ã  minha
vida (se Ã© que Ã© uma &ldquo;vida&rdquo;, porÃ©m a todos os efeitos prÃ¡ticos, como nÃ£o faz
diferenÃ§a mesmo, Ã© uma vida, simulada ou nÃ£o) que o fato de vivermos ou nÃ£o em
uma simulaÃ§Ã£o.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
