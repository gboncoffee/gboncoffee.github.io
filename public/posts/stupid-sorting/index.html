<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="shortcut icon" href="/profile.png" />

<title>Stupid Sorting&nbsp;|&nbsp;Gabriel G. de Brito</title>
<meta
  name="title"
  content="Stupid Sorting"
/>
<meta
  name="description"
  content="The first topic in “Algoritmos e Estruturas de Dados II” (“Algorithms and Data Structures II”) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It’s not really that usefull but it’s a great example to learn. Then we learn stuff like the Insertion Sort, which’s actually usefull and more complex to understand.
But, as stupid as Selection Sort is, it’s kinda straightforward. What about some really, really stupid and useless sorting algorithms?"
/>
<meta
  name="keywords"
  content=""
/>

  <meta name="author" content="Gabriel G. de Brito" />




<meta property="og:url" content="http://localhost:1313/posts/stupid-sorting/">
  <meta property="og:site_name" content="Gabriel G. de Brito">
  <meta property="og:title" content="Stupid Sorting">
  <meta property="og:description" content="The first topic in “Algoritmos e Estruturas de Dados II” (“Algorithms and Data Structures II”) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It’s not really that usefull but it’s a great example to learn. Then we learn stuff like the Insertion Sort, which’s actually usefull and more complex to understand.
But, as stupid as Selection Sort is, it’s kinda straightforward. What about some really, really stupid and useless sorting algorithms?">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-12T10:02:53-03:00">
    <meta property="article:modified_time" content="2023-09-12T10:02:53-03:00">




<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Stupid Sorting">
<meta name="twitter:description" content="The first topic in “Algoritmos e Estruturas de Dados II” (“Algorithms and Data Structures II”) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It’s not really that usefull but it’s a great example to learn. Then we learn stuff like the Insertion Sort, which’s actually usefull and more complex to understand.
But, as stupid as Selection Sort is, it’s kinda straightforward. What about some really, really stupid and useless sorting algorithms?">





  <meta itemprop="name" content="Stupid Sorting">
  <meta itemprop="description" content="The first topic in “Algoritmos e Estruturas de Dados II” (“Algorithms and Data Structures II”) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It’s not really that usefull but it’s a great example to learn. Then we learn stuff like the Insertion Sort, which’s actually usefull and more complex to understand.
But, as stupid as Selection Sort is, it’s kinda straightforward. What about some really, really stupid and useless sorting algorithms?">
  <meta itemprop="datePublished" content="2023-09-12T10:02:53-03:00">
  <meta itemprop="dateModified" content="2023-09-12T10:02:53-03:00">
  <meta itemprop="wordCount" content="666">
<meta name="referrer" content="no-referrer-when-downgrade" />

    
    <link href="/simple.min.css" rel="stylesheet" />

    
    <link href="/style.min.css" rel="stylesheet" />

    

    
</head>

  <body>
    <header>
      <nav>
  <a
    href="/"
    
    >Me</a
  >

  <a
    href="/projects/"
    
    >Projects</a
  >

  <a
    href="/posts/"
    
    >Posts</a
  >

  <a
    href="/literature/"
    
    >Literature</a
  >


  <a href="/index.xml">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512">
      
      <path
        d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0A64 64 0 1 1 0 416zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"
      />
    </svg>
    RSS
  </a>

</nav>

<h1>Stupid Sorting</h1>


    </header>
    <main>
      
  
  
  <content>
    <p>The first topic in “Algoritmos e Estruturas de Dados II” (“Algorithms and Data Structures II”) classes are sorting algorithms. The first one we learn is the stupid Selection Sort. It’s not really that usefull but it’s a great example to learn. Then we learn stuff like the Insertion Sort, which’s actually usefull and more complex to understand.</p>
<p>But, as stupid as Selection Sort is, it’s kinda straightforward. What about some really, really stupid and useless sorting algorithms?</p>
<p>For this algorithms I used some <code>#includes</code> and a simple function that checks if an array is sorted. The entire source is available <a href="https://gist.github.com/gboncoffee/2ecfacb0bc7f03626e4c1d2e4d00253f">here at GitHub</a>.</p>
<h2 id="kill-sort">Kill Sort</h2>
<p>Sorts the array by removing unsorted itens. Returns the final size.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">int</span> kill_sort(<span class="dt">int</span> *v, <span class="dt">int</span> n)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>{</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="dt">int</span> pad = <span class="dv">0</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        <span class="cf">if</span> (v[i] &lt; v[i - <span class="dv">1</span> - pad])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>            pad++;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="cf">else</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>            v[i - pad] = v[i];</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="cf">return</span> n - pad;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The cool thing about this one is that it keeps the pointer valid. Of course, it’s usefull if we want a sorted array but don’t need all the elements. It’s linear too, which is very cheap, but it writes a lot, and that’s not great if writes are expensive.</p>
<h2 id="thanos-sort">Thanos Sort</h2>
<p>Sorts the array by removing a random half of it until it’s sorted. Returns the final array pointer and sets n to it’s size.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">int</span>* thanos_sort(<span class="dt">int</span> *v, <span class="dt">int</span> *n)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>{</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    srand(time(NULL));</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="cf">while</span> (*n &gt; <span class="dv">1</span> &amp;&amp; !sorted(v, *n)) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="cf">if</span> (random() % <span class="dv">2</span>) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>            v += *n / <span class="dv">2</span>;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        }</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        *n = *n / <span class="dv">2</span>;</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    }</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="cf">return</span> v;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>Very similar to Kill Sort. Unfortunatelly, this one leads to much more data loss and does not have predictable behaviour. But it does not make a single write in the array and runs in logarithmic time. Extremelly cheap. Also, it may not keep the pointer valid, and that’s why it returns a new one. This should be used with caution to not cause memory leaks.</p>
<h2 id="random-sort">Random Sort</h2>
<p>Sorts the array by randomizing a sequence and them checking if it’s sorted.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">void</span> random_sort(<span class="dt">int</span> *v, <span class="dt">int</span> n)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>{</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="dt">int</span> x, y, tmp;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    srand(time(NULL));</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="cf">while</span> (!sorted(v, n)) {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>            x = random() % n;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>            y = random() % n;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>            tmp = v[x];</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>            v[x] = v[y];</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>            v[y] = tmp;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        }</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>This one is fun. It has a little chance of sorting the array in a single iteration. I tested with an array with 10 elements and it usuallys takes between 300 thousand and 700 thousand iterations to finish. As it have a chance of running a single iteration, it have a chance of never sorting at all too.</p>
<h2 id="intelligent-design-sort">Intelligent Design Sort</h2>
<p>Sorts the array by the following principle:<br />
- There’s n! chance of the array being sorted;<br />
- So it must have been sorted by an intelligent designer.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">void</span> intelligent_design_sort(<span class="dt">int</span> *v, <span class="dt">int</span> n)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>{</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    (<span class="dt">void</span>) v;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    (<span class="dt">void</span>) n;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is the cheapest algorithm here. Runs in constant time and uses only a single stack frame of memory <em>at all, without compiler optimization</em>. I’ve only ever saw very few functions cheapest than this in computer science, and they’re usually not usefull at all.</p>
<h2 id="miracle-sort">Miracle Sort</h2>
<p>Sorts the array by waiting and hoping cosmic rays are going to flip the memory so the array get’s sorted.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">void</span> miracle_sort(<span class="dt">int</span> *v, <span class="dt">int</span> n)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>{</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="cf">while</span> (!sorted(v, n))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        sleep(<span class="dv">5</span>);</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Yeah it just sits there and patiently waits for a miracle. You can adjust the sleep time to change the behaviour of the algorithm: more time will lead to a slightly slower sort, but less CPU usage. Less time will lead to a slightly faster sort, but more CPU usage.</p>
<h2 id="schrodinger-sort">Schrodinger Sort</h2>
<p>It’s not sorted nor unsorted until you check it.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">int</span> schrodinger_sort(<span class="dt">int</span> *v, <span class="dt">int</span> n)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>{</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="cf">return</span> sorted(v, n);</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>It sorts the array by telling you if it’s sorted or not, so you decides what to do. Quantum mechanics are really cool, aren’t they?</p>

  </content>
  <p>
    
  </p>

    </main>
    <footer>
      
  <span>© Gabriel G. de Brito (CC-BY-NC)</span>


  <span>
    |
    Made with
    <a href="https://github.com/maolonglong/hugo-simple/">Hugo ʕ•ᴥ•ʔ Simple</a>
  </span>


    </footer>

    
</body>
</html>
