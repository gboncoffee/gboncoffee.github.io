<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="shortcut icon" href="/profile.png" />

<title>Another Update On Text Editors&nbsp;|&nbsp;Gabriel G. de Brito</title>
<meta
  name="title"
  content="Another Update On Text Editors"
/>
<meta
  name="description"
  content="(or How I Got Into The Nerdiest Thing Ever &#43; Rant On Modern Unix) Some weeks ago I wrote a blogpost about my journey on text editor hopping, and them another blogpost reviewing my own post. Well, here we go again.
In the last post I wrote about Plasma and the Unix philosophy in the desktop but that’s mostly bullshit. And that’s why the Linux desktop is a mess.
Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc."
/>
<meta
  name="keywords"
  content=""
/>

  <meta name="author" content="Gabriel G. de Brito" />




<meta property="og:url" content="http://localhost:1313/posts/update-on-text-editors-again/">
  <meta property="og:site_name" content="Gabriel G. de Brito">
  <meta property="og:title" content="Another Update On Text Editors">
  <meta property="og:description" content="(or How I Got Into The Nerdiest Thing Ever &#43; Rant On Modern Unix) Some weeks ago I wrote a blogpost about my journey on text editor hopping, and them another blogpost reviewing my own post. Well, here we go again.
In the last post I wrote about Plasma and the Unix philosophy in the desktop but that’s mostly bullshit. And that’s why the Linux desktop is a mess.
Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-21T01:49:27-03:00">
    <meta property="article:modified_time" content="2023-12-21T01:49:27-03:00">




<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Another Update On Text Editors">
<meta name="twitter:description" content="(or How I Got Into The Nerdiest Thing Ever &#43; Rant On Modern Unix) Some weeks ago I wrote a blogpost about my journey on text editor hopping, and them another blogpost reviewing my own post. Well, here we go again.
In the last post I wrote about Plasma and the Unix philosophy in the desktop but that’s mostly bullshit. And that’s why the Linux desktop is a mess.
Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc.">





  <meta itemprop="name" content="Another Update On Text Editors">
  <meta itemprop="description" content="(or How I Got Into The Nerdiest Thing Ever &#43; Rant On Modern Unix) Some weeks ago I wrote a blogpost about my journey on text editor hopping, and them another blogpost reviewing my own post. Well, here we go again.
In the last post I wrote about Plasma and the Unix philosophy in the desktop but that’s mostly bullshit. And that’s why the Linux desktop is a mess.
Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc.">
  <meta itemprop="datePublished" content="2023-12-21T01:49:27-03:00">
  <meta itemprop="dateModified" content="2023-12-21T01:49:27-03:00">
  <meta itemprop="wordCount" content="674">
<meta name="referrer" content="no-referrer-when-downgrade" />

    
    <link href="/simple.min.css" rel="stylesheet" />

    
    <link href="/style.min.css" rel="stylesheet" />

    

    
</head>

  <body>
    <header>
      <nav>
  <a
    href="/"
    
    >Me</a
  >

  <a
    href="/projects/"
    
    >Projects</a
  >

  <a
    href="/posts/"
    
    >Posts</a
  >

  <a
    href="/literature/"
    
    >Literature</a
  >


  <a href="/index.xml">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512">
      
      <path
        d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0A64 64 0 1 1 0 416zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"
      />
    </svg>
    RSS
  </a>

</nav>

<h1>Another Update On Text Editors</h1>


    </header>
    <main>
      
  
  
  <content>
    <h1 id="or-how-i-got-into-the-nerdiest-thing-ever-rant-on-modern-unix">(or How I Got Into The Nerdiest Thing Ever + Rant On Modern Unix)</h1>
<p>Some weeks ago I wrote <a href="http://localhost:1313/posts/on-text-editors/">a blogpost</a> about my journey on text editor hopping, and them <a href="http://localhost:1313/posts/update-on-text-editors/">another blogpost</a> reviewing my own post. Well, here we go again.</p>
<p>In the last post I wrote about Plasma and the Unix philosophy in the desktop but that’s mostly bullshit. And that’s why the Linux desktop is a mess.</p>
<p>Instead of the original Unix idea of multiple programs writing text to others, the Linux desktop is based on other APIs like the X server itself, dbus and etc.␣And often they don’t talk the same language. QT vs GTK is an example of this, alongside with desktop portals, notification daemons, etc.</p>
<p>Well, I wasn’t happy with Plasma’s design philosophy because of bloat. I tried GNOME but it’s worse. End up on XFCE.</p>
<p>XFCE is better as it’s simple and minimal. But I really wanted to go back to using window managers and stuff like that.</p>
<p>What I found out is that, in the end, what I really care about is having a sane and cohesive shell (using “shell” as “interface”). Plasma is a kinda cohesive graphical shell, but it’s not that efficient. Menu-bar-driven, two-button mouse systems, i.e., the modern graphical paradigm popularized by the Microsoft Windows operating system, is not efficient.</p>
<p>One could argue that the Unix terminal is more efficient, but I found it very incohesive. First, the shell language is a mess. Second, the command argument syntaxes are very diverse. Third, the ANSI terminal itself. It’s an ancient hack that stick with us and should’ve been dropped when graphical interfaces became popular. We’d never implemented simple graphics API though so the result is that it’s 2023 and we’re still using curses. Also, modern Unix got a lot of stuff wrong, mainly due to the Free Software Foundation and the GNU project push towards the bloat. Much GNU documentation is acessible via the <code>info</code> pages that nobody really knows how to read, some commands have a <code>--help</code>, some have the manual (which is much better than any other alternative, <em>specially</em> <code>info</code> pages). And the manual opens inside the pager with a broken view in my terminal because it doesn’t support bold.</p>
<p>And them we got Emacs. Emacs is actually a very cohesive shell, but it’s painfully slow and it’s not particularly efficient. It’s probably the least painfull way to use the GNU system “the way it was intented” nowadays, which is kinda funny because Emacs is it’s own containeirized Lisp operating system.</p>
<p>Wandering through the web, I read some Rob Pike’s papers and found out the nerdiest thing in computing: <a href="https://plan9.io/plan9/">Plan 9 From Bell Labs</a>. It’s almost perfect. The graphical shell is extremelly efficient, the mouse usage is geniously simple and easy, yet fast. The entire system is very simple and straighforward. So much that I had the Plan 9 From User Space port installed in my Debian system and in a couple hours I had learned everything I had to learn to be as efficient as I’m after years of learning Unix with my new shell and toys.</p>
<p>Acme is specially a rather efficient shell. And, different from the hack that’s the graphical Emacs, it was meant to be a shell. Everything is so cool that I’ll be changing to a very minimalistic Unix system - <a href="https://www.alpinelinux.org/">Alpine</a>, so I can have everything in busybox and statically linked with musl - and using basically the Plan 9 tools and other minimalistic software to do my computing. I liked Plan 9 so much that I’m writing my own <code>rio</code> clone for X11.</p>
<p>And I know exactly what I liked in it. Basically, the system allows, via the mouse, easy and free exchanging of text between different programs, running in parallel in the graphical environment, with a cohesive interface. It’s possible to create such shell for Unix, but it would be a rather difficult task. Much difficultier than for Plan 9 as there would be no support from the system itself. I may try it though.</p>

  </content>
  <p>
    
  </p>

    </main>
    <footer>
      
  <span>© Gabriel G. de Brito (CC-BY-NC)</span>


  <span>
    |
    Made with
    <a href="https://github.com/maolonglong/hugo-simple/">Hugo ʕ•ᴥ•ʔ Simple</a>
  </span>


    </footer>

    
</body>
</html>
